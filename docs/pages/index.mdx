import { HomeHero, Divider } from '@/components/home-page';

<HomeHero />

## 왜 써야할까요?

효율적인 서버는 인프라 비용을 낮추고, 부하가 걸렸을 때 응답성이 향상되며, 사용자 만족도가 높다는 것을 의미합니다.
보안 검증과 편리한 개발을 희생하지 않고도 가능한 한 많은 요청을 처리하면서 서버의 리소스를 효율적으로 처리할 수 있는 방법은 무엇일까요?

바로 Fastify입니다. Fastify는 최소한의 오버헤드와 강력한 플러그인 아키텍처로 최고의 개발자 경험을 제공하는 데 중점을 둔 웹 프레임워크로, Hapi와 Express에서 영감을 받았습니다.
우리가 아는 한, 가장 빠른 웹 프레임워크 중 하나입니다.

## 핵심 기능

다음은 Fastify가 구축된 주요 특징과 원칙입니다:

- **고성능**: 우리가 아는 한, Fastify는 코드 복잡도에 따라 초당 최대 3만 건의 요청을 처리할 수 있는 가장 빠른 웹 프레임워크 중 하나입니다.
- **확장성**: Fastify는 후크, 플러그인 및 데코레이터를 통해 완전히 확장할 수 있습니다.
- **스키마 기반**: 필수는 아니지만 경로의 유효성을 검사하고 출력을 직렬화하기 위해 [JSON Schema](http://json-schema.org/)를 사용할 것을 권장하며, 내부적으로 Fastify는 고성능 함수에서 스키마를 컴파일합니다.
- **Logging**: 로그는 매우 중요하지만 비용이 많이 들기 때문에 이 비용을 거의 제거할 수 있는 최고의 Logger인 [Pino](https://github.com/pinojs/pino)를 선택했습니다!
- **개발자 친화적**: 프레임워크는 매우 표현력이 뛰어나며 성능과 보안을 희생하지 않으면서도 개발자가 일상적으로 사용할 수 있도록 만들어졌습니다.
- **TypeScript 지원**: 성장하는 [TypeScript](https://www.typescriptlang.org/) 커뮤니티를 지원할 수 있도록 TypeScript 유형 선언 파일을 유지하기 위해 열심히 노력하고 있습니다.

## Request/Response 유효성 검사와 hooks

물론 Fastify는 이보다 훨씬 더 많은 작업을 수행할 수 있습니다.

예를 들어 JSON 스키마를 사용하여 입력 및 출력 유효성 검사를 쉽게 제공하고 핸들러가 실행되기 전에 특정 작업을 수행할 수 있습니다:

```js
const fastify = require('fastify')({ logger: true });

fastify.route({
  method: 'GET',
  url: '/',
  schema: {
    // request needs to have a querystring with a `name` parameter
    querystring: {
      type: 'object',
      properties: {
        name: { type: 'string' },
      },
      required: ['name'],
    },
    // the response needs to be an object with an `hello` property of type 'string'
    response: {
      200: {
        type: 'object',
        properties: {
          hello: { type: 'string' },
        },
      },
    },
  },
  // this function is executed for every request before the handler is executed
  preHandler: async (request, reply) => {
    // E.g. check authentication
  },
  handler: async (request, reply) => {
    return { hello: 'world' };
  },
});

const start = async () => {
  try {
    await fastify.listen({ port: 3000 });
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};
start();
```

## TypeScript 지원

Fastify는 타입 파일과 함께 제공되지만 사용 중인 Node.js 버전에 따라 `@types/node`를 설치해야 할 수도 있습니다.

다음 예제는 http 서버를 생성합니다.

사용하는 http 버전에 대한 관련 타입을 전달합니다.

타입을 전달하면 경로의 기본 http 객체에 대한 올바른 타입의 액세스를 얻을 수 있습니다.

http2를 사용하는 경우 `<http2.Http2Server, http2.Http2ServerRequest, http2.Http2ServerResponse>`가 전달됩니다.

https의 경우 Server 대신 `http2.Http2SecureServer` 또는 `http.SecureServer`를 전달합니다.

이렇게 하면 서버 핸들러 내에서 `reply.res`에 올바른 입력이 포함된 `http.ServerResponse`를 얻을 수 있습니다.

```ts
import Fastify, { FastifyInstance, RouteShorthandOptions } from 'fastify';
import { Server, IncomingMessage, ServerResponse } from 'http';

const server: FastifyInstance = Fastify({});

const opts: RouteShorthandOptions = {
  schema: {
    response: {
      200: {
        type: 'object',
        properties: {
          pong: {
            type: 'string',
          },
        },
      },
    },
  },
};

server.get('/ping', opts, async (request, reply) => {
  return { pong: 'it worked!' };
});

const start = async () => {
  try {
    await server.listen({ port: 3000 });

    const address = server.server.address();
    const port = typeof address === 'string' ? address : address?.port;
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }
};
start();
```
